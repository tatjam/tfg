#include "Wake.h"

using namespace Eigen;

void Wake::shed_from(const ThinWing &wing, double wake_scale, Eigen::Index num_edges, Eigen::Vector3d body_vel,
					 Eigen::Vector3d omega)
{
	// Create vertices, starting from the trailing edge
	// We index similarly to wings, (xi * num_edges + zi)
	// where xi represents moving along the trialing edge, and zi moving back into the wake
	size_t num_trailing_edge = wing.trailing_edge.rows();
	vertices = Array3Xd(3, num_trailing_edge * num_edges);
	for(Index i = 0; i < wing.trailing_edge.rows(); i++)
	{
		vertices.col(i * num_edges + 0) = wing.transform * wing.vertices.col(wing.trailing_edge(i));
	}

	// Consider an observer situated in the ground, seeing the wing move.
	// The (unperturbed) wake is the set of points that the trailing edge of the
	// wing touches as it moves.
	// the set of those points are generated by integrating:
	// dx/dt (inertial) = dx/dt (rotating) + Omega * x
	// Where dx / dt (rotating) = body_vel  by definition
	// While this problem has an analytical solution, it's way simpler
	// to numerically integrate the equations
	// (We in fact integrate backwards in time)

	// State vector
	Vector3d body_pos; body_pos.setZero();
	Isometry3d body_orient; body_orient.setIdentity();

	double omega_length = omega.norm();
	Vector3d omega_norm = omega / omega_length;

	for(Index zi = 1; zi < num_edges; zi++)
	{
		// This is kind of "velocity" cosine sampling
		double progress = (double)zi / (double)(num_edges - 1);
		//double pos = 1.0 - std::cos(M_PI * progress * 0.5);
		// This is kind of like a "time-step", that increases further away from the body
		double speed = std::sin(M_PI * progress * 0.5);

		// Integrate velocity
		Vector3d inertial_vel = body_orient * body_vel;
		body_pos -= inertial_vel * speed * wake_scale;
		//body_pos += -(body_vel - omega.cross(body_pos)) * speed * wake_scale;

		// Integrate rotation
		if(omega_length > 0.0)
		{
			body_orient = body_orient.rotate(AngleAxisd(-omega_length * speed * wake_scale, omega_norm));
		}

		for(Index xi = 0; xi < num_trailing_edge; xi++)
		{
			Vector3d vertex_pos = wing.transform * wing.vertices.col(wing.trailing_edge(xi)).matrix();
			Vector3d rotated = body_orient * vertex_pos;
			Vector3d rel_pos = body_pos + rotated;
			vertices.col(xi * num_edges + zi) = rel_pos;
		}
	}

	// Generate the rectangles, same as for the wing
	quads = Array4Xi(4, (num_trailing_edge - 1) * (num_edges - 1));

	for(int xi = 0; xi < num_trailing_edge - 1; xi++)
	{
		for(int zi = 0; zi < num_edges - 1; zi++)
		{
			quads(0, xi * (num_edges - 1) + zi) = xi * num_edges + zi;
			quads(1, xi * (num_edges - 1) + zi) = (xi + 1) * num_edges + zi;
			quads(2, xi * (num_edges - 1) + zi) = (xi + 1) * num_edges + zi + 1;
			quads(3, xi * (num_edges - 1) + zi) = xi * num_edges + zi + 1;
		}
	}
}
